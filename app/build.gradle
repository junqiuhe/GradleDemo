apply plugin: 'com.android.application'

apply plugin: HelloPlugin1
apply plugin: HelloPlugin2

android {
    compileSdkVersion rootProject.ext.android.compileSdkVersion
    defaultConfig {
        applicationId rootProject.ext.android.applicationId
        minSdkVersion rootProject.ext.android.minSdkVersion
        targetSdkVersion rootProject.ext.android.targetVersion
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"

        multiDexEnabled true

        /**
         * 将编译变量注入清单:
         * https://developer.android.google.cn/studio/build/manifest-build-variables
         *
         * 将build.gradle文件中定义的变量插入到 AndroidManifest.xml 文件中.
         */
        manifestPlaceholders = [hostName: "www.sample.com"]

        /**
         * 默认情况下，在AndroidManifest.xml 中 ${applicationId} 占位符 将提供应用的 应用ID.
         */
    }

    def keyFile = file('s.keystore.temp')

    Properties properties = new Properties()
    properties.load(rootProject.file('local.properties').newDataInputStream())

    def keystoreFilePath = properties.getProperty("keystore.path")
    if(keystoreFilePath){
        keyFile = file(keystoreFilePath)
    }

    signingConfigs {
        release {
            storeFile keyFile
            storePassword properties.getProperty("keystore.password")
            keyAlias = properties.getProperty("keystore.alias")
            keyPassword properties.getProperty("keystore.alias_password")
        }
    }

    /**
     *
     * Reference source: https://developer.android.google.cn/studio/build/build-variants
     *
     * Gradle automatically creates build variants base on your 'build types' and 'product flavors'
     * and names the according to <product-flavor><build-type>
     * For example:
     * 1、demoDebug
     * 2、demoRelease
     * 3、fullDebug
     * 4、fullRelease
     *
     *  一、Configuration buildType.
     *  Android Studio automatically creates the debug and release buildType.
     *
        buildTypes{
            debug{
            }
            release{
            }
        }

        二、Configuration Product Flavors.
        The product flavors support the same properties as 'defaultConfig'.
        this is because 'defaultConfig' actually belongs to the 'ProductFlavor' class.

        flavorDimensions "version"
        productFlavors{
            demo{
                dimension "version"
            }
            full{
                dimension "version"
            }
        }
     */

    /**
     * Combine multiple product flavors with flavor dimensions
     * In some cases, you may want to combine configurations from multiple product flavors.
     * For example, you may want to create different configurations for the 'full' and 'demo' product flavors
     * that are based on api level.
     *
     * Gradle does not combine product flavors that belong to the same flavor dimension.
     *
     * for example: the following code will creates a total of 12 build variants with the following naming scheme:
     *
     * build variant: [minApi24, minApi23, minApi21][demo, full][debug, release]
     * corresponding apk: app-[minApi24, minApi23, minApi21][demo, full][debug, release].apk
     */
    buildTypes {

        debug{
            debuggable true
            applicationIdSuffix ".debug"
        }

        release {
            /**
             * Enables code shrinking, obfuscation and optimization for only your project's release build type.
             */
            minifyEnabled true

            /**
             * Enables resource shrinking
             */
            shrinkResources true

            if(keyFile.exists()){
                signingConfig signingConfigs.release
            }else {
                println("WITH -> buildTypes -> release: using default key")
            }

            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }

        /**
         * Android Studio 3.0及Gradle Plugin 3.0升级注意事项:
         *
         *      https://blog.csdn.net/codezjx/article/details/78627403
         *
         * 处理 app 与 library 依赖匹配问题.
         *
         * 情景4：若library没有任何dimension和flavor，则不需app做任何flavor的回退处理~
         *
         * 情形1：app中有个某个build type, 但Library却没有.
         *
         * (注意: 在该情形下，若library中有某个build type但app却没有，不会对app有任何印象)
         */
        staging{
            minifyEnabled true

            shrinkResources true

            if(keyFile.exists()){

                println("WITH -> buildTypes -> release: using jks key")

                signingConfig signingConfigs.release

            }else {
                println("WITH -> buildTypes -> release: using default key")
            }

            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'

            matchingFallbacks = ['release']
        }
    }

    flavorDimensions "api", "mode"
    productFlavors{
        demo{
            dimension "mode"
            applicationIdSuffix ".demo"
        }

        /**
         * 处理 app 与 library 依赖匹配问题.
         *
         * 情形2：在同一个dimension维度下，如mode, 若app中有某个flavor但library却没有
         *
         * （注意：在该情景下，若library中有某个flavor但app却木有，不会对app有任何影响）
         *
         * for example: 同一dimension维度'mode'下，app有full,但library没有full。会编译错误.
         */
        full{
            dimension "mode"
            applicationIdSuffix ".full"
            matchingFallbacks = ['demo']
        }

        minApi24{
            dimension "api"
            minSdkVersion 24
            versionCode 30000 + android.defaultConfig.versionCode
            versionNameSuffix "-minApi24"
        }

        minApi23{
            dimension "api"
            minSdkVersion 23
            versionCode 20000  + android.defaultConfig.versionCode
            versionNameSuffix "-minApi23"
        }

        minApi21{
            dimension "api"
            minSdkVersion 21
            versionCode 10000  + android.defaultConfig.versionCode
            versionNameSuffix "-minApi21"
        }
    }

    /**
     * Filter minApi21demoDebug and minApi21demoRelease.
     */
//    variantFilter{ variant ->
//        def names = variant.flavors*.name
//        if(names.contains("minApi21") && names.contains("demo")){
//            setIgnore(true)
//        }
//    }

    /**
     * By default, Android Studio creates the main/ source set and directories for everything you want to share between all your build variant.
     * However, you can create new source sets to control exactly what files Gradle compiles and packages for specific build types, product flavors and build variant.
     *
     * For example, you can define basic functionality in the main/ source set and use product flavor source sets to change the branding of your app for different clients.
     * or include special permissions and logging functionality only for build variants that use the debug build type.
     *
     * For example: following priority
     * 1、src/demoDebug
     * 2、src/debug
     * 3、src/demo
     * 4、src/main
     */
    sourceSets {

        demo{
            java.srcDirs = ["src/demosrc/java"]
            res.srcDirs = ['src/demosrc/res']
        }

        full{
            java.srcDirs = ["src/fullsrc/java"]
            res.srcDirs = ['src/fullsrc/res']
        }
    }

    //批量修改APK名称的配置
    applicationVariants.all { variant ->
        variant.outputs.all{ output ->

            println "ourputFile: ${output.outputFile.name}, " +
                    "flavorName: ${variant.flavorName}, " +
                    "buildType: ${variant.buildType.name}"

            def fileName = "jackh_${variant.flavorName}_${variant.buildType.name}_${buildTime()}.apk"
            outputFileName = fileName
            println fileName
        }
    }
}

static def buildTime(){
    return new Date().format("yyyyMMdd", TimeZone.getTimeZone("UTC"))
}


/**
 * 添加配置依赖项
 */
dependencies {

    //dependency on a local library module.
    implementation project(":mylibrary")

    //dependency on a local binaries
    implementation fileTree(dir: 'libs', include: ['*.jar'])

    def multidex_version = "2.0.1"
    implementation "androidx.multidex:multidex:$multidex_version"

    //dependency on a remote binaries
    implementation rootProject.ext.dependencies["appcompat"]
    implementation rootProject.ext.dependencies["constriant"]

    testImplementation rootProject.ext.dependencies["junit"]
    androidTestImplementation rootProject.ext.dependencies["androidJunit"]
    androidTestImplementation rootProject.ext.dependencies["espresso-core"]
}



//------------------------------------
/**
 * 一、Gradle的构建周期.
 *  1.1、Initialization
 *      在该阶段，Gradle将会确定哪些项目参与构建，并为每个项目创建一个Project对象实例.
 *      对于Android项目即执行 'settting.gradle' 文件.
 *
 *  1.2、Configuration
 *      对于Android项目即为执行各个module下的 'build.gradle' 文件，这样各个 'build.gradle'文件中的task依赖关系才会被确定。
 *
 *  1.3、Execution
 *      task的执行阶段.
 *
 * 注意: 写在Task闭包中的内容是在 configure 阶段执行的
 *    而doFirst、doLast是在 execution 阶段执行的.
 */
task a {
    println "task a "
}

task(taskBoth) {
    //依赖a task先执行
    dependsOn("a")

    println "我会在Configuration和Execution阶段都执行"

    doFirst {
        println "我仅在testBoth的Execution阶段执行"
    }

    doLast {
        println "我仅在testBoth的Execution阶段执行"
    }
}

/**
 * Hook Gradle 构建过程.
 */
//task badHook{
//    tasks.findByName("assembleDebug").doFirst{
//        println "hook afterEvaluate from BadHook"
//    }
//}
task assHook {
    afterEvaluate {
        tasks.findByName("assembleDebug").doFirst {
            println "hook afterEvaluate from assHook"
        }
    }
}

//task hookAssets {
//    afterEvaluate {
//        tasks.findByName("packageDebug").doFirst { task ->
//            copy {
//                def sourcePath = "${projectDir.absolutePath}/test.png"
//
//                def targetPath = "${task.assets.asFile.get()}"
//
//                println "sourcePath: ${sourcePath}, targetPath: ${targetPath}"
//
//                from sourcePath
//                into targetPath
//            }
//        }
//    }
//}

//task (name: actionTest, action: new Action<Task>() {
//    @Override
//    void execute(Task task) {
//        println 'hello'
//    }
//}) {
//}

/**
 * Gradle支持Task类的书写, 以便提高Task的复用性
 */
class GreetingTask extends DefaultTask {
    String greeting = "hello from GreetingTask"

    @TaskAction
    def greet() {
        println greeting
    }
}

task hello(type: GreetingTask)

task greeting(type: GreetingTask) {
    greeting = "greetings from GreetingTask"
}

/**
 * Task 实战
 *
 * 1、install apk之前必须有一个apk，因此必须依赖一个assembleDebug task
 * 2、exec 闭包的参数
 *      2.1、workingDir: 工作环境, 默认为当前project目录
 *      2.2、commandLine: 需要命令行执行的命令
 */
task installAndRun(dependsOn: 'assembleDebug') {
    doFirst {
        exec {
            workingDir "${buildDir}/outputs/apk/debug"
            commandLine 'adb', 'install', '-r', 'app-debug.apk'
        }
        exec {
            //AndroidManifest.xml的路径
            def path = "${buildDir}/intermediates/instant_app_manifest/debug/AndroidManifest.xml"
//            def path = "${buildDir}/intermediates/manifests/full/debug/AndroidManifest.xml"

            /**
             * Groovy 解析XML
             * http://docs.groovy-lang.org/latest/html/documentation/#_processing_xml
             */
            //xml解析
            def parser = new XmlParser(false, false).parse(new File(path))

            //application 下的每一个 activity 结点
            parser.application.activity.each { activity ->

                // activity 下的每一个 intent-filter 结点
                activity.'intent-filter'.each { filter ->
                    // intent-filter 下的 action 结点中的 @android:name 包含 android.intent.action.MAIN
                    if (filter.action.@"android:name".contains("android.intent.action.MAIN")) {
                        def targetActivity = activity.@"android:name"

                        commandLine 'adb', 'shell', 'am', 'start', '-n', "${android.defaultConfig.applicationId}/${targetActivity}"
                    }
                }
            }
        }
    }
}

/**
 * 创建插件的方式一: build script.
 */
class HelloPlugin1 implements Plugin<Project>{
    @Override
    void apply(Project project) {
        project.task("helloPlugin1Task"){

            group 'customPlugin'

            doFirst {
                println "Hello Plugin 1"
            }
        }
    }
}